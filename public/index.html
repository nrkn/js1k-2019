<!DOCTYPE html><html><!-- note: your demo in this shim runs in an iframe with this content: https://gist.github.com/qfox/3cccc4f36c8319e09bb7 --><!--
  (c) js1k.com 2019
  Note: submissions belong to their respective owner, do not copy without their consent
  --><head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Security-Policy" content="
    connect-src              'none'                                                             ;
    default-src              'none'                                                             ;
    font-src                 'self'                                                             ;
    frame-src                'self'            data:                                            ;
    worker-src                'self'            data:                                            ;
    img-src                  'self'            data:            ssl.google-analytics.com        ;
    media-src                data:                                                              ;
    object-src               data:                                                              ;
    style-src                'self'            data:            'unsafe-inline'                 ;
    script-src               'unsafe-inline'   'unsafe-eval'    www.google-analytics.com        ;
  " help="please report csp-related problems to valid demos!">

    <title>JS1k 2019 - NNNN - TITLE</title>
    <meta name="author" content="YOU">
    <script>
      // GA
    </script>
    <style>
      /* https://qfox.nl/notes/333 */
      body,html,iframe{margin:0;padding:0;border:0;width:100%;height:100%}
      iframe{position:absolute;top:0;left:0;padding-top:50px;box-sizing:border-box}
      header{position:relative;z-index:1;height:47px;padding-top:2px;border-bottom:1px solid #000;box-shadow:0 -10px 25px #ccc inset;background-color:#eee}
      aside,div,h1,p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;text-align:center;font-size:16px;font-weight:inherit;line-height:22px;padding:0;margin:0;cursor:default}
      aside,h1{display:inline}
      a{color:#000;text-decoration:none;border-bottom:1px dashed #000}
      a:hover{border-bottom:1px solid red}
      a[href="0"]{text-decoration:line-through;pointer-events:none;border-bottom:0;color:#ccc}
      .button{float:left;width:40px;height:40px;line-height:40px;text-align:center;padding:0;margin:2px 0 0 10px;border:1px solid #888;border-color:#ddd #888 #888 #ddd;font-family:sans-serif;font-size:30px;font-weight:700;cursor:pointer}
      .button:hover{color:red;border-bottom-color:#888}
      .r{margin-right:10px}
      time{display:none}
    </style>
  </head>
  <body>
    <header>
      <div>
        <h1>
          <a href="https://js1k.com/">JS1k</a>
          <a href="https://js1k.com/2019-x">2019</a>
          <strong></strong> demo
          —
          "TITLE" by YOU
        </h1>
        <p>
          <em>
            FIRST PART OF YOUR DESC GOES HERE
          </em>
        </p>
        <aside>
          —
          1024 bytes
          —
          <a href="https://js1k.com/2019-x/details/NNNN">demo details</a>
          —
          <a href="https://js1k.com/2019-x/demos">list of demos</a>
          —
          <a href="https://js1k.com/NNNN" title="short link for your mobile devices" rel="nofollow">js1k.com/NNNN</a>
          <time datetime="NOW" pubdate="">NOW</time>
        </aside>
      </div>

      <a href="500" class="button p">↞</a>
      <a href="502" class="button n">↠</a>
    </header>

    <script type="shim">
      // this is the SHIM (will be ran in the context of the iframe...)

      // unprefix some popular vendor prefixed things (but stick to their original name)
      iwin.AudioContext = iwin.AudioContext || iwin.webkitAudioContext; // ios8 unmutes audio only during the first user triggered event with sound
      iwin.requestAnimationFrame = iwin.requestAnimationFrame || iwin.mozRequestAnimationFrame || iwin.webkitRequestAnimationFrame || iwin.msRequestAnimationFrame || function(f){ iwin.setTimeout(f, 1000/30); };
      canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
      if (typeof OscillatorNode !== 'undefined' && OscillatorNode.prototype) {
        OscillatorNode.prototype.start = OscillatorNode.prototype.start || OscillatorNode.prototype.noteOn;
        OscillatorNode.prototype.stop = OscillatorNode.prototype.stop || OscillatorNode.prototype.noteOff;
      }

      a = canvas;
      b = idoc.body;
      d = idoc.document;

      if (!TOKEN_WEBGL) iwin.c = canvas.getContext('2d');
      else iwin.g = (function () {
        iwin.onorientationchange = iwin.onresize = null;
        try {
          var o = { antialias: true, stencil: true };
          var gl = canvas.getContext('webgl', o) || canvas.getContext('experimental-webgl', o);

          // keep in scope, must not be garbage collected
          iwin.__glExts =
            [ 'OES_texture_float', 'OES_texture_float_linear', 'OES_standard_derivatives',
              'EXT_texture_filter_anisotropic', 'MOZ_EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic',
              'WEBGL_compressed_texture_s3tc', 'MOZ_WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc'
            ].map(function(ext) {
                return gl.getExtension(ext);
              });
        } catch (e) {
          idoc.body.innerHTML = 'WebGL not supported.';
          iwin.a=iwin.b=iwin.c=iwin.d=null;
          throw e;
        }

        return gl;
      })();
    </script>
    <script>
      // submission form configurables:

      // enable canvas shim at all? (2d/3d). other settings are ignored if this is false.
      var TOKEN_CANVAS_SHIM = true;
      // true enables webgl shim (exposes `g`), false enables canvas shim (exposes `c`)
      var TOKEN_WEBGL = false;
      // px, 0 means always 100%
      var TOKEN_MAX_WIDTH = 315;
      // px, 0 means always 100%
      var TOKEN_MAX_HEIGHT = 315;
      // should the size be smaller than specified if viewport is smaller?
      var TOKEN_MAX_100P = true;
      // only if width<100%
      var TOKEN_CENTER_CANVAS = false;
      // "press" reload button on orientation change?
      var TOKEN_RELOAD_ONORIENTATIONCHANGE = true;
    </script>
    <script type="demo">"use strict";
// closure so that uglify won't treat any variables as local
let s = () => {
    /*
      6x7 1-bit sprites packed into chars - drawn as 7x7 to have square tiles
  
      You can use 7x7 but for it to fit into the printable ascii range so you can
      put it in a normal javascript string, the high bit has to be set, so if you
      have a sprite that doesn't use the 7th column you have to find some value
      you can xor the charcodes with so that all the rows still fit in the
      printable ascii range (therefore 1byte per char in utf8).
  
      It's a clever solution but you can save the bytes you'd use doing this by
      just making them 1 column smaller instead.
    */
    let sprites = 'a~j~a@mq`j`jassm^@a@plkjj@{{{{q{@bTHTb';
    // constants will get inlined
    let VIEWSIZE = 9;
    let TILESIZE = 5;
    let floor = 3;
    let potion = 5;
    let stairs = 6;
    let sword = 7;
    let playerSprite = 0;
    let monsterSprite = 1;
    let potionSprite = 2;
    let stairsSprite = 3;
    let swordSprite = 4;
    let exitSprite = 5;
    let swordAmount = 1;
    // global state
    let level = 0;
    let mapData;
    let mobs;
    let draw = () => {
        // start draw
        // clear the canvas
        a.width = VIEWSIZE * 7 * TILESIZE;
        // draw the map tiles within the viewport
        for (let viewY = 0; viewY < VIEWSIZE; viewY++) {
            for (let viewX = 0; viewX < VIEWSIZE; viewX++) {
                /*
                  see if there is a sprite at this map position, we use 7 as the guard
                  for "no sprite here"
                */
                let spriteIndex = (
                /*
                  note the weird mapData[ x + 'string' + y ] pattern here
      
                  first use of this pattern - basically we join the x and y together
                  with an arbitrary string and use it for a key into the mapData
                  object
      
                  by making mapData an object instead of an array we don't have to
                  worry about out of bounds and etc
      
                  we join the x and y together with the most common string from the
                  rest of the code to assist with packing
                */
                mobs[(viewX - 4 + mobs[0][0])
                    + 'fd9640' +
                    (viewY - 4 + mobs[0][1])]
                    &&
                        mobs[(viewX - 4 + mobs[0][0])
                            + 'fd9640' +
                            (viewY - 4 + mobs[0][1])][2] ?
                    mobs[(viewX - 4 + mobs[0][0])
                        + 'fd9640' +
                        (viewY - 4 + mobs[0][1])][3] :
                    mapData[(viewX - 4 + mobs[0][0])
                        + 'fd9640' +
                        (viewY - 4 + mobs[0][1])] == potion ?
                        potionSprite :
                        mapData[(viewX - 4 + mobs[0][0])
                            + 'fd9640' +
                            (viewY - 4 + mobs[0][1])] == sword ?
                            swordSprite :
                            mapData[(viewX - 4 + mobs[0][0])
                                + 'fd9640' +
                                (viewY - 4 + mobs[0][1])] == stairs ?
                                // on the last level show exit sprite instead of stairs
                                level < 5 ? stairsSprite : exitSprite :
                                7);
                c.fillStyle = (mobs[(viewX - 4 + mobs[0][0])
                    + 'fd9640' +
                    (viewY - 4 + mobs[0][1])]
                    &&
                        mobs[(viewX - 4 + mobs[0][0])
                            + 'fd9640' +
                            (viewY - 4 + mobs[0][1])][2] ?
                    '#' + 'fd9640'[mobs[(viewX - 4 + mobs[0][0])
                        + 'fd9640' +
                        (viewY - 4 + mobs[0][1])][2]] + 37 :
                    // is there a sprite?
                    mapData[(viewX - 4 + mobs[0][0])
                        + 'fd9640' +
                        (viewY - 4 + mobs[0][1])] ?
                        '#' + 964 :
                        // use different colored walls for each level
                        '#' + 37 + 'fd9640'[level]);
                // check if we have a monster or player here
                // todo - mobs array has references to mobs as properties as well as
                // indexers - can we just use that here, will it save bytes?
                // if(
                //   mobs[
                //     ( viewX - 4 + mobs[ 0 ][ 0 ] )
                //     + 'fd9640' +
                //     ( viewY - 4 + mobs[ 0 ][ 1 ] )
                //   ][ 2 ]
                // )
                // for ( let i = 0; i < mobs.length; i++ ) {
                //   if (
                //     mobs[ i ][ 2 ]
                //     &&
                //     mobs[ i ][ 0 ] == viewX - 4 + mobs[ 0 ][ 0 ]
                //     &&
                //     mobs[ i ][ 1 ] == viewY - 4 + mobs[ 0 ][ 1 ]
                //   ) {
                //     // mobs[][ 3 ] is the spriteIndex for the mob, monster or player
                //     spriteIndex = mobs[ i ][ 3 ]
                //     /*
                //       color it according to how much health it has left, towards red
                //       as it gets lower
                //     */
                //     c.fillStyle = '#' + 'fd9640'[ mobs[ i ][ 2 ] ] + 37
                //   }
                // }
                // iterate over the pixels for the current sprite
                for (let spriteY = 0; spriteY < 7; spriteY++) {
                    for (let spriteX = 0; spriteX < 7; spriteX++) {
                        if ((
                        /*
                          if it's the player, draw a sword in the last row. as the
                          player picks up more sword upgrades, the sword gets bigger
                        */
                        spriteIndex == playerSprite
                            &&
                                spriteX == 6
                            &&
                                spriteY < 6
                            &&
                                spriteY > 4 - swordAmount)
                            ||
                                (
                                // if there's a sprite, true if the bit is set at this pixel
                                spriteIndex < 7
                                    &&
                                        !((sprites.charCodeAt(spriteIndex * 7 + spriteY)) >> spriteX & 1))
                            ||
                                // there's no map data, it will draw a wall
                                !mapData[(viewX - 4 + mobs[0][0])
                                    + 'fd9640' +
                                    (viewY - 4 + mobs[0][1])]) {
                            c.fillRect(spriteX * TILESIZE + viewX * 7 * TILESIZE, spriteY * TILESIZE + viewY * 7 * TILESIZE, TILESIZE, TILESIZE);
                        }
                    }
                }
            }
        }
        // end draw
    };
    // generate a new random map
    let createMap = (health) => {
        // initalise the tile currently being randomly added, first is always 0,0
        let current = [0, 0];
        // base size of the map
        let size = 96;
        // reset state
        mapData = {};
        /*
          add the player as the first mob
          if we went down a level restore the player's health to what it was
        */
        mobs = [[0, 0, health, 0]];
        /*
          mobs is an array AND an object, that way we can iterate over it but
          also get a mob at a specific position without having to iterate over it
        */
        mobs[(0)
            + 'fd9640' +
            (0)] = mobs[0];
        // randomly add tiles to the map, as the level gets higher make it bigger
        for (let i = 0; i < (size * (level + 1)); i++) {
            // by default it will be a floor tile
            mapData[(current[0])
                + 'fd9640' +
                (current[1])] = floor;
            // but some chance of it being a potion
            if (current[0] !== mobs[0][0] &&
                !~~(Math.random() * (size * (level + 1)) / (level + 7))) {
                mapData[(current[0])
                    + 'fd9640' +
                    (current[1])] = potion;
            }
            // or a monster
            else if (current[0] !== mobs[0][0]
                &&
                    !~~(Math.random() * (size * (level + 1)) / (level + 7))
                &&
                    !mobs[(current[0])
                        + 'fd9640' +
                        (current[1])]) {
                /*
                  create a new monster, place it at the end of the mobs array, then
                  also add it to the array as a property so we can look up mobs by
                  position without iterating
                */
                mobs[(current[0])
                    + 'fd9640' +
                    (current[1])] = mobs[mobs.length] = [
                    current[0],
                    current[1],
                    ~~(Math.random() * 5) + 1,
                    monsterSprite
                ];
            }
            // now pick a random direction to add to the map next
            let dir = ~~(Math.random() * 4);
            /*
              when the player wins we don't generate anything, so the level generated
              after triggering the exit is empty, it causes a graphical glitch
              which makes a nice win screen
            */
            if (level < 6) {
                // make the current tile the tile in the new direction
                current = [
                    current[0] + [0, -1, 1, 0][dir],
                    current[1] + [-1, 0, 0, 1][dir]
                ];
            }
        }
        // make the last tile visited the stairs to the next level
        mapData[(current[0])
            + 'fd9640' +
            (current[1])] = stairs;
    };
    // key handler, triggers the game loop
    b.onkeydown = e => {
        // iterate over all mobs including player
        for (let i = 0; i < mobs.length; i++) {
            // the damage the players sword will do this turn if it hits a monster
            let damage = ~~(Math.random() * swordAmount) + 1;
            // a random action for monsters to take
            let action = ~~(Math.random() * 4);
            // will hold a code to determine movement
            let which;
            /*
              which will get overridden if it's the player, but if it's a monster:
            */
            // move in a random direction 50% of the time
            if (action < 2) {
                which = ~~(Math.random() * 4) + 37;
            }
            // try to move towards the player on the x axis
            else if (action < 3) {
                which = mobs[0][0] < mobs[i][0] ? 37 : 39;
            }
            // try to move towards the player on the y axis
            else {
                which = mobs[0][1] < mobs[i][1] ? 38 : 40;
            }
            // only process mobs which are alive - health is stored in mobs[][2]
            if (mobs[i][2]) {
                // if i is 0 it's the player, use the keycode from the event
                which = i ? which : e.which;
                // left and right modifier
                let x = which == 37 ? -1 : which == 39 ? 1 : 0;
                // up and down modifier
                let y = which == 38 ? -1 : which == 40 ? 1 : 0;
                if (
                // dest is floor
                (mapData[(mobs[i][0] + x)
                    + 'fd9640' +
                    (mobs[i][1] + y)] == floor)
                    &&
                        // no other mob here
                        !mobs[(mobs[i][0] + x)
                            + 'fd9640' +
                            (mobs[i][1] + y)]) {
                    // delete the mob from the array properties at the old location
                    mobs[(mobs[i][0])
                        + 'fd9640' +
                        (mobs[i][1])] = 0;
                    // update the mobs position to the new location
                    mobs[i][0] = mobs[i][0] + x;
                    mobs[i][1] = mobs[i][1] + y;
                    // re-add the mob as a property of the array at the new location
                    mobs[(mobs[i][0])
                        + 'fd9640' +
                        (mobs[i][1])] = mobs[i];
                }
                else if (
                // dest is another mob
                mobs[(mobs[i][0] + x)
                    + 'fd9640' +
                    (mobs[i][1] + y)]) {
                    // monster attacks player
                    if (
                    // current mob is not player
                    i
                        &&
                            // target is player
                            !mobs[(mobs[i][0] + x)
                                + 'fd9640' +
                                (mobs[i][1] + y)][3]
                        &&
                            // 50% chance to hit
                            ~~(Math.random() * 2)) {
                        // decrement player health
                        mobs[(mobs[i][0] + x)
                            + 'fd9640' +
                            (mobs[i][1] + y)][2]--;
                        // if player dead, restart
                        if (!mobs[(mobs[i][0] + x)
                            + 'fd9640' +
                            (mobs[i][1] + y)][2]) {
                            // reset some of the state
                            level = 0;
                            swordAmount = 1;
                            createMap(5);
                        }
                    }
                    // player attacks mob
                    else if (
                    // current mob is player
                    !i
                        &&
                            // there is a mob here
                            mobs[(mobs[i][0] + x)
                                + 'fd9640' +
                                (mobs[i][1] + y)]
                        &&
                            // mob is not already dead
                            mobs[(mobs[i][0] + x)
                                + 'fd9640' +
                                (mobs[i][1] + y)][2]) {
                        if (
                        // monster is still alive
                        mobs[(mobs[i][0] + x)
                            + 'fd9640' +
                            (mobs[i][1] + y)][2]) {
                            //decrement monster health according to damage determined earlier
                            mobs[(mobs[i][0] + x)
                                + 'fd9640' +
                                (mobs[i][1] + y)][2]
                                =
                                    mobs[(mobs[i][0] + x)
                                        + 'fd9640' +
                                        (mobs[i][1] + y)][2] - damage;
                        }
                        if (
                        // health is 0 or less
                        mobs[(mobs[i][0] + x)
                            + 'fd9640' +
                            (mobs[i][1] + y)][2] <= 0) {
                            /*
                              set health to zero in case it was negative so we can test it for
                              falsiness, negatives are truthy
                            */
                            mobs[(mobs[i][0] + x)
                                + 'fd9640' +
                                (mobs[i][1] + y)][2] = 0;
                            // delete it from the array properties
                            mobs[(mobs[i][0] + x)
                                + 'fd9640' +
                                (mobs[i][1] + y)] = 0;
                            // maybe drop a sword
                            if (!~~(Math.random() * 5)) {
                                mapData[(mobs[i][0] + x)
                                    + 'fd9640' +
                                    (mobs[i][1] + y)] = sword;
                            }
                        }
                    }
                }
                // dest is potion, take
                else if (
                // current mob is player
                !i
                    &&
                        // is potion
                        mapData[(mobs[i][0] + x)
                            + 'fd9640' +
                            (mobs[i][1] + y)] == potion) {
                    // remove the potion
                    mapData[(mobs[i][0] + x)
                        + 'fd9640' +
                        (mobs[i][1] + y)] = floor;
                    // if player health not already max increment
                    if (mobs[i][2] < 5)
                        mobs[i][2]++;
                }
                else if (
                // current mob is player
                !i
                    &&
                        // is sword
                        mapData[(mobs[i][0] + x)
                            + 'fd9640' +
                            (mobs[i][1] + y)] == sword) {
                    // remove the sword from the map
                    mapData[(mobs[i][0] + x)
                        + 'fd9640' +
                        (mobs[i][1] + y)] = floor;
                    // if sword amount not max increment
                    if (swordAmount < 5)
                        swordAmount++;
                }
                // dest is stairs, go down
                else if (
                // current mob is player
                !i
                    &&
                        // is stairs
                        mapData[(mobs[i][0] + x)
                            + 'fd9640' +
                            (mobs[i][1] + y)] == stairs) {
                    // generate a new level
                    level++;
                    // have to pass player health through so it doesn't get lost
                    createMap(mobs[i][2]);
                }
            }
        }
        draw();
    };
    // first run, set the player's initial health and draw
    createMap(5);
    draw();
};
s();
//# sourceMappingURL=index.js.map</script>
    <script>
      (function(){var doc=document;var header=doc.getElementsByTagName("header")[0];var firstChild=header.firstChild;var p=doc.getElementsByClassName("p")[0];
      var n=doc.getElementsByClassName("n")[0];header.insertBefore(p,firstChild);header.insertBefore(n,firstChild);header.appendChild(doc.getElementsByTagName
      ("p")[0])})();(function reload(fullscreen){var doc=document;var header=doc.getElementsByTagName("header")[0];var iframe=doc.createElement("iframe");doc.
      body.appendChild(iframe);var iwin=iframe.contentWindow;var idoc=iframe.contentDocument;idoc.open();idoc.close();idoc.write("<!doctype html>"+'<html st'+
      'yle="margin: 0; padding: 0; border: 0;'+(TOKEN_CANVAS_SHIM?' width: 100%; height: 100%;':'')+'">'+"<head>"+'<meta charset="utf-8">'+'<body style="mar'+
      'gin: 0; padding: 0; border: 0;'+(TOKEN_CANVAS_SHIM?' width: 100%; height: 100%;':'')+'">'+(TOKEN_CANVAS_SHIM?'<canvas style="display: block;'+(
      TOKEN_CENTER_CANVAS?" margin: auto;":"")+'"></canvas>':"")+"");if(TOKEN_CANVAS_SHIM){var canvas=idoc.getElementsByTagName("canvas")[0];var cs=canvas.style
      ;idoc.body.clientWidth;cs.width=(canvas.width=Math.max(Math.min(TOKEN_MAX_WIDTH||innerWidth,innerWidth),0)||0)+"px";cs.height=(canvas.height=Math.max(
      Math.min(TOKEN_MAX_HEIGHT||innerHeight-50,innerHeight-50),0)||0)+"px"}if(TOKEN_RELOAD_ONORIENTATIONCHANGE)onorientationchange=reloadClick;iwin.AudioContext
      =iwin.AudioContext||iwin.webkitAudioContext;iwin.requestAnimationFrame=iwin.requestAnimationFrame||iwin.mozRequestAnimationFrame||iwin.
      webkitRequestAnimationFrame||iwin.msRequestAnimationFrame||function(f){iwin.setTimeout(f,1E3/30)};if(TOKEN_CANVAS_SHIM)canvas.requestPointerLock=canvas.
      requestPointerLock||canvas.mozRequestPointerLock||canvas.webkitRequestPointerLock;idoc.body.requestPointerLock=idoc.body.requestPointerLock||idoc.body.
      mozRequestPointerLock||idoc.body.webkitRequestPointerLock;navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.
      mozGetUserMedia||navigator.msGetUserMedia;var iwo=iwin.OscillatorNode&&iwin.OscillatorNode.prototype;iwo&&(iwo.start=iwo.start||iwo.noteOn)&&(iwo.stop=iwo
      .stop||iwo.noteOff);if(TOKEN_CANVAS_SHIM)iwin.a=canvas;iwin.b=idoc.body;d=idoc;if(TOKEN_CANVAS_SHIM){if(!TOKEN_WEBGL)iwin.c=canvas.getContext("2d");if(
      TOKEN_WEBGL)iwin.g=function(){iwin.onorientationchange=iwin.onresize=null;try{var o={antialias:true,stencil:true};var gl=canvas.getContext("webgl",o)||
      canvas.getContext("experimental-webgl",o);iwin.__glExts=["OES_texture_float","OES_texture_float_linear","OES_standard_derivatives","EXT_texture_filter_"+
      "anisotropic","MOZ_EXT_texture_filter_anisotropic","WEBKIT_EXT_texture_filter_anisotropic","WEBGL_compressed_texture_s3tc","MOZ_WEBGL_compressed_textur"+
      "e_s3tc","WEBKIT_WEBGL_compressed_texture_s3tc"].map(function(ext){return gl.getExtension(ext)})}catch(e){idoc.body.innerHTML="WebGL not supported.";iwin
      .a=iwin.b=iwin.c=iwin.d=null;throw e;}return gl}()}var demo=idoc.createElement("script");demo.textContent=doc.querySelector('script[type="demo"]').
      textContent;idoc.body.appendChild(demo);idoc.close();iframe.contentWindow.focus();var firstLine=doc.getElementsByTagName("div")[0];function reloadClick(b)
      {doc.body.removeChild(iframe);r.parentElement.removeChild(r);iframe=null;r=null;idoc=null;header=null;reload(b)}window.reload=reloadClick;var r=doc.
      createElement("div");r.innerHTML="&#8635;";r.className="button r";r.title="restart just the demo (local, without remote fetch)";r.onclick=reloadClick;
      header.insertBefore(r,firstLine)})();
    </script>
  

</body></html>